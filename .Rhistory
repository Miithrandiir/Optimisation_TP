# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/rs.csv", header = TRUE, sep = " ")
setwd("~/Development/ulco/M1/Optimisation_verel/TP1")
# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/rs.csv", header = TRUE, sep = " ")
# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/result.csv", header = TRUE, sep = " ")
# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/result.csv", header = TRUE, sep = ",")
df.rs <- c(df.rs$Max.try, df.rs$fitness)
# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/result.csv", header = TRUE, sep = ",")
# si besoin renommer les 2 colonnes :
names(df.rs) <- c("nbeval", "fitness")
# vÃ©rification du fichier: affiche les premiÃ¨res lignes
head(df.rs)
# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/result.csv", header = TRUE, sep = ",")
# si besoin renommer les 2 colonnes :
names(df.rs) <- c("id", "nbeval", "fitness")
# vÃ©rification du fichier: affiche les premiÃ¨res lignes
head(df.rs)
# histogramme pour un nombre d'Ã©valuation 10000 : nota, la distribution n'est pas gaussienne
hist(df.rs[df.rs$nbeval == 10000,]$fitness)
# calcul de la moyenne
mean(df.rs[df.rs$nbeval == 10000,]$fitness)
# rÃ©sumÃ© des principales statistiques
summary(df.rs[df.rs$nbeval == 10000,]$fitness)
# nuage de points des fitness obtenues en fonction du nombre d'Ã©valuation
plot(fitness ~ nbeval, data = df.rs)
# chargement de la librairie doBy
library(doBy)
# calcul des moyennes de fitness en fonction du nombre d'Ã©valuation
df.rs.mean <- summaryBy(fitness ~ nbeval, data = df.rs)
# plot correspondant
plot(fitness.mean ~ nbeval, data = df.rs.mean)
# grosso modo, on a l'impression que les donnÃ©es suivent une loi logarithmique
# d'ailleur, on peut tracer avec le log:
plot(fitness.mean ~ log10(nbeval), data = df.rs.mean)
# et mÃªme fitter un modÃ¨le linÃ©aire
model <- lm(fitness.mean ~ log10(nbeval), data = df.rs.mean)
# trace la droite de rÃ©gression
abline(model)
# donne le descriptif du modÃ¨le : noter un trÃ¨s bon coefficient R^2
summary(model)
# split des donnÃ©es selon les valeur en ligne (obtient alors une liste)
l <- split(df.rs$fitness, factor(df.rs$nbeval))
# boite a moustache (boxplot) de la fitness en fonction du nombre d'Ã©valuation (attention echelle non respectÃ©e en abscisse)
boxplot(l)
# calcul des moyennes (nota: R est un langage fonctionnel)
l.mean <- lapply(l, FUN = mean)
# et le plot fitness vs. moyenne
plot(names(l.mean), unlist(l.mean))
# lit les donnÃ©es de la marche alÃ©atoire
df.rw <- read.table("rw.csv", header = TRUE, sep = " ")
# Bien mettre le chemin du rÃ©pertoire de travail (Session -> Set Working Directory -> To Source File Location)
setwd("~/Development/ulco/M1/Optimisation_verel/TP1")
############################
# recherche alÃ©atoire
# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/result.csv", header = TRUE, sep = ",")
# si besoin renommer les 2 colonnes :
names(df.rs) <- c("id", "nbeval", "fitness")
# vÃ©rification du fichier: affiche les premiÃ¨res lignes
head(df.rs)
# histogramme pour un nombre d'Ã©valuation 10000 : nota, la distribution n'est pas gaussienne
hist(df.rs[df.rs$nbeval == 10000,]$fitness)
# calcul de la moyenne
mean(df.rs[df.rs$nbeval == 10000,]$fitness)
# rÃ©sumÃ© des principales statistiques
summary(df.rs[df.rs$nbeval == 10000,]$fitness)
# nuage de points des fitness obtenues en fonction du nombre d'Ã©valuation
plot(fitness ~ nbeval, data = df.rs)
# chargement de la librairie doBy
library(doBy)
# calcul des moyennes de fitness en fonction du nombre d'Ã©valuation
df.rs.mean <- summaryBy(fitness ~ nbeval, data = df.rs)
# plot correspondant
plot(fitness.mean ~ nbeval, data = df.rs.mean)
# grosso modo, on a l'impression que les donnÃ©es suivent une loi logarithmique
# d'ailleur, on peut tracer avec le log:
plot(fitness.mean ~ log10(nbeval), data = df.rs.mean)
# et mÃªme fitter un modÃ¨le linÃ©aire
model <- lm(fitness.mean ~ log10(nbeval), data = df.rs.mean)
# trace la droite de rÃ©gression
abline(model)
# donne le descriptif du modÃ¨le : noter un trÃ¨s bon coefficient R^2
summary(model)
## Remarque : sans la librairie doBy
# split des donnÃ©es selon les valeur en ligne (obtient alors une liste)
l <- split(df.rs$fitness, factor(df.rs$nbeval))
# boite a moustache (boxplot) de la fitness en fonction du nombre d'Ã©valuation (attention echelle non respectÃ©e en abscisse)
boxplot(l)
# calcul des moyennes (nota: R est un langage fonctionnel)
l.mean <- lapply(l, FUN = mean)
# et le plot fitness vs. moyenne
plot(names(l.mean), unlist(l.mean))
# lit les donnÃ©es des recherches alÃ©atoires
df.rs <- read.table("./cmake-build-release/result.csv", header = TRUE, sep = ",")
# si besoin renommer les 2 colonnes :
names(df.rs) <- c("id", "nbeval", "fitness")
# vÃ©rification du fichier: affiche les premiÃ¨res lignes
head(df.rs)
# histogramme pour un nombre d'Ã©valuation 10000 : nota, la distribution n'est pas gaussienne
hist(df.rs[df.rs$nbeval == 10000,]$fitness)
# calcul de la moyenne
mean(df.rs[df.rs$nbeval == 10000,]$fitness)
# rÃ©sumÃ© des principales statistiques
summary(df.rs[df.rs$nbeval == 10000,]$fitness)
# nuage de points des fitness obtenues en fonction du nombre d'Ã©valuation
plot(fitness ~ nbeval, data = df.rs)
# chargement de la librairie doBy
library(doBy)
# calcul des moyennes de fitness en fonction du nombre d'Ã©valuation
df.rs.mean <- summaryBy(fitness ~ nbeval, data = df.rs)
# plot correspondant
plot(fitness.mean ~ nbeval, data = df.rs.mean)
